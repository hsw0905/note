# 의존성을 이용해 설계 진화시키기

## 의존성
- 설계 : 어떤 클래스에 어떤 코드를 넣을 것인가 (코드 배치)
- A가 B에 의존할 경우 A -> B
	- B가 변경될 때 A도 같이 변경될 수 있다.
- 클래스 사이 의존성
	- 연관 관계
		- ```Java
			public class A {
			    private B b;
			}
			```
	- 의존 관계
		- ```Java
			public class A {
			    ...
			    public B method(B b) {
			        return new B();
			  }
			}
			```
	- 상속 관계
		- ```Java
			public class A extends B {
			    ...
			}
			```
	- 실체화 관계
		- ```Java
			public class A implements B {
			    ...
			}
			```

- 패키지 사이 의존성
	- 패키지에 포함된 클래스 사이의 의존성
		- import문에 다른 패키지가 나온다.

### 의존성 가이드
- 양방향 의존성을 피하라 -> 왠만하면 단방향 의존으로 바꿀 것
	- 이유
		- 싱크를 맞춰야 함
		- 성능 이슈
- 다중성이 적은 방향을 선택하라
	- 컬렉션을 가지게 되는 OneToMany 보다 ManyToOne 관계를 가지게 할 것
- 의존성이 필요없다면 제거하라
- 패키지 사이의 의존성 사이클을 제거하라
	- A,B,C 패키지 사이에 사이클이 돈다 -> A,B,C 패키지가 하나였어야 한다.

### 관계의 종류 결정하기
- 연관 관계
	- 개념 : 탐색 가능성
		- A 객체를 알면 내가 원하는 B 객체를 찾아갈 수 있다.
	- 두 객체 사이에 협력이 필요하고, 두 객체의 관계가 영구적이라면 연관 관계를 이용해 탐색 경로를 구현한다.
	- 일반적인 구현 방법
		- 객체 참조를 사용한다.
- 의존 관계
	- 협력을 위해 일시적으로 필요한 의존성(파라미터, 리턴타입, 지역변수)

## 설계 개선하기
- 구현한 코드에 대하여 의존성을 손으로 그려보기
- 의존성이 이상한 부분이 발견되면 내가 원했던 의존성 방향으로 개선하기

### 대표적인 의존성에 대한 개선할 문제
- 객체 참조로 인한 결합도 상승
	- 객체를 어디까지 조회할 것인가? (Lazy 로딩 이슈)
	- 객체를 어디까지 수정할 것인가? (하나의 긴 트랜잭션으로 묶이는 이슈)
		- 트랜잭션 경합으로 인한 성능 저하
		- 해결 방법
			- 함께 생성되고 함께 삭제되는 객체들은 함께 묶어라
				- 경계 밖의 객체는 ID를 이용해 접근하라
			- 도메인 제약사항을 공유하는 객체들을 함께 묶어라
			- 가능하면 분리하라
			- 절차지향 방법이 때로는 더 좋은 방법일 때도 있다
			- Domain Event를 이용한 의존성 제거
- 패키지 사이의 의존성 사이클
	- 해결 방법
		- 중간 객체를 이용한 의존성 사이클 끊기
		- 인터페이스나 추상클래스 등을 사용하여 의존성 방향을 역전시키기
		- 새로운 패키지로 분리하기
	- 도메인 단위의 모듈화
		- 시스템 분리의 기반

### 추상화
- 잘 변하지 않는 것
- 반드시 추상클래스나 인터페이스여야 한다는 오해의 소지가 있다.
- 클래스로도 상대적으로 변하지 않는 추상화를 표현할 수 있다.
